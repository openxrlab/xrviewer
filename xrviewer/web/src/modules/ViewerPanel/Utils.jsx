import * as BABYLON from '@babylonjs/core';
import { saveAs } from 'file-saver';

export function ExportOBJ(mesh: BABYLON.Mesh) {
  // Q: Why not mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind) ?
  // A: For skeletal meshes, getVerticesData does not returns the vertex
  //   positions after applying the skeleton.
  // eslint-disable-next-line no-underscore-dangle
  const verts = mesh._getPositionData(true);
  const indices = mesh.getIndices();
  const n_verts = verts.length / 3;
  const n_faces = indices.length / 3;

  const objData = [];
  objData.push('# Generated by XRViewer');
  for (let i = 0; i < n_verts; i++) {
    objData.push(
      // eslint-disable-next-line prefer-template
      'v '
      + Number(verts[i * 3]).toPrecision(8) + ' '
      + Number(verts[i * 3 + 1]).toPrecision(8) + ' '
      + Number(verts[i * 3 + 2]).toPrecision(8),
    );
  }

  let ccw = true;
  console.log(BABYLON.Tags.GetTags(mesh, true));
  if (BABYLON.Tags.MatchesQuery(mesh, 'skeletalMesh')) {
    ccw = false;
  }

  let lhs = 1;
  let rhs = 2;
  if (ccw) {
    lhs = 2;
    rhs = 1;
  }
  // faces are 1-based for obj files
  for (let i = 0; i < n_faces; i++) {
    objData.push(
      // eslint-disable-next-line prefer-template
      'f '
      + (indices[i * 3] + 1) + ' '
      + (indices[i * 3 + lhs] + 1) + ' '
      + (indices[i * 3 + rhs] + 1),
    );
  }
  const file = new Blob([objData.join('\n')], { type: 'text/plain;charset=utf-8' });
  // eslint-disable-next-line prefer-template
  const filename = new Date().toLocaleString() + '.obj';

  saveAs(file, filename);
}
